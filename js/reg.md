1. 正则表达式匹配两个特定字符之间的内容
- 匹配字符串A与B之间的内容（包含A和B）
表达式：A.*?B("."表示任意字符，"?"表示匹配0个或者多个)
- 匹配A与B（包含A不包含B）
表达式：A.*?(?=B)
- 匹配A与B（不包含A包含B）
表达式：(?<=A).*?B

2. 匹配最后出现的字符串，以字符a为例
reg表达式：(a)(?!.*\1)


## js正则表达式
- 创建
    - 字面量(静态)
    ```
    const reg = /abc/
    ```
    - 构造函数(动态，根据变量来定义的 )
    ```
    const reg = new RegExp("abc")
    ```
- 语法
    - ^和$的对比: ^匹配字符串的行首;$匹配字符串的行尾
    ```
    const reg = /^A/,reg1 = /t$/
    reg.test("Ant")
    reg1.test("Ant")
    ```
    - 重复限定符(*,+,?,{n},{n,}{n,m}): *匹配前一个字符0次或多次(x>=0);+匹配前一个字符1次或者多次(x>=1);
    ?匹配前一个字符的0次或者1次(x = 0 || x = 1);{n}匹配前一个字符n次(x = 0);{n,}匹配前一个字符n次或大于n次(x>=n);
    {n,m}匹配前一个字符n次到m次之间(n <= x <= m)
    ```
    const  reg1 = /a*/,reg2 = /a+/..
    ```
    - 元字符(.,\d,\w,\s,\b): .匹配除换行符以外的所有字符; \d匹配数字字符，等价于[0-9](digital);
    \w匹配字母、数字和下划线(word);\s匹配空白符(空格、换行符、制表符)(space);\b匹配一个边界，一个独立单词的开头或结尾
    (border)
    - 反元字符([^X],\D,\W,\B,\S):  [^x]匹配x之外的任意字符;\D匹配除数字之外的任意字符，与\d相反;同理\D与\d相反，\W与\w相反...
    - 字符组([...]): [...]匹配方括号中的字符集合，例如[0-9]=>匹配数字字符
    ```
    const reg = /[a-z]/
    ```
    - 分组((...))
    (X): 将括号中的字符看成一个组进行匹配，例如(ab)+ => 可以匹配"abababab"
    (?:X): 匹配X，但是不记录匹配项
    (?=X): 正向肯定查找，即匹配后面紧跟X的字符串
    (?!X): 正向否定查找，即匹配后面不跟X的字符串，与(?:X)相反
    - 多选字符(|): |匹配两者中的一个，例如a|b => 匹配a或这b
    - 转义字符(\)
- 匹配方式
    - 贪婪模式: 即以限定符最大重复标准进行匹配，例如: 使用/ba*/匹配"baaaaa"时，结果可返回"baaaaa"
    - 非贪婪模式: 即以限定符最小重复标准进行匹配，例如: 使用/ba*?/匹配"baaaa"时，结果可返回"b"
- 标识方式：正则表达式后面跟的匹配方式
    - g: 全局匹配，记忆方式(global)
    - i: 忽略大小写(ignore)
    - m: 多行搜索(multline)
- 方法：reg有两种，String有四种
    - reg的两种exec和test
    ```
    //test => 判断字符串中是否存在与正则表达式匹配的字符串，返回boolean类型
    const reg = /abc/
    //exec => 匹配字符串中满足的字符串，返回一个数组
    ```
    - string有四种match、search、replace、split
    ```
    //match查找字符串匹配的字符串，返回一个数组
    //search返回匹配字符串的下标，没有则返回-1
    //replace替换，返回新的字符串
    //split使用正则表达式或者固定字符，分割字符串
    ```

